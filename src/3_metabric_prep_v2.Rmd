---
title: "3. Prepare METABRIC data"
output: html_notebook
---

## Initial setup

### Load libraries
```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(limma) # For vennDiagram
})
```

### Set paths
```{r}
proj_dir <- "~/Dropbox (HMS)/_projects_/B06 03 HR-APM/"

fig_dir <- file.path(proj_dir, "manuscript", "figs")
obj_dir <- file.path(proj_dir, "manuscript", "RData")
data_dir <- file.path(proj_dir, "data")
metabric_dir <- file.path(data_dir, "brca_metabric")

```

### Gene list
```{r}
x <- load(file=file.path(obj_dir,"1-4_prep","gene_signature.rda")) # gene.sig,category,hallmarks
```

## Load expresssion data (downloaded form cBioPortal)
```{r}
fns <- file.path(metabric_dir, c(
  "data_expression_median.txt",
  "data_mRNA_median_Zscores.txt",
  "data_mRNA_median_all_sample_Zscores.txt"
))

meta.mat1 <- read.table(fns[1], sep = "\t", header = TRUE, stringsAsFactors = FALSE)
meta.mat2 <- read.table(fns[2], sep = "\t", header = TRUE, stringsAsFactors = FALSE)
meta.mat3 <- read.table(fns[3], sep = "\t", header = TRUE, stringsAsFactors = FALSE)

meta.mat1[1:5, 1:5] # Preview of the first matrix's top-left corner

```

### Check column names
Column names of the three matrices are identical.
```{r}
identical(colnames(meta.mat1), colnames(meta.mat2)) # Should return TRUE
identical(colnames(meta.mat1), colnames(meta.mat3)) # Should return TRUE
```

## Pre-processing data
### Compare three expression matrices
```{r}
## colnames - identical
meta.m1 <- as.matrix(meta.mat1[,-(1:2)])
rownames(meta.m1) <- meta.mat1$Hugo_Symbol ## genes whose expression is measured

meta.m2 <- as.matrix(meta.mat2[,-(1:2)])
rownames(meta.m2) <- meta.mat2$Hugo_Symbol ## genes whose expression is measured

meta.m3 <- as.matrix(meta.mat3[,-(1:2)])
rownames(meta.m3) <- meta.mat3$Hugo_Symbol ## genes whose expression is measured

dim(meta.m1) # 24368 genes, 1904 samples
dim(meta.m2) # 18543 genes, 1904 samples
dim(meta.m3) # 24368 genes, 1904 samples
```

### mat1 and mat3 have identical gene sets.
```{r}
identical(meta.mat1$Hugo_Symbol,meta.mat3$Hugo_Symbol) # true
```

### colnames are unique
```{r}
table(table(colnames(meta.m3)))
```


#### Consistency between 3 batches
```{r}
if(0){
  syms12 <- intersect(meta.mat1$Hugo_Symbol,meta.mat2$Hugo_Symbol)
  i=4
  pdf(file.path(fig_dir,"3_prep_metabric","mat1vs2.pdf"),width=7,height=7)
  plot(meta.m1[match(syms12[i],meta.mat1$Hugo_Symbol),],
  	meta.m2[match(syms12[i],meta.mat2$Hugo_Symbol),],
  	main=syms12[i],
  	xlab="M1",ylab="M2",	
  	pch=20)
  dev.off()

  pdf(file.path(fig_dir,"3_prep_metabric","mat1vs3.pdf"),width=7,height=7)
  plot(meta.m1[match(syms12[i],meta.mat1$Hugo_Symbol),],
  	meta.m3[match(syms12[i],meta.mat3$Hugo_Symbol),],
  	main=syms12[i],
  	xlab="M1",ylab="M3",
  	pch=20)
  dev.off()

  pdf(file.path(fig_dir,"3_prep_metabric","mat2vs3.pdf"),width=7,height=7)
  plot(meta.m2[match(syms12[i],meta.mat2$Hugo_Symbol),],
    meta.m3[match(syms12[i],meta.mat3$Hugo_Symbol),],     
  	main=syms12[i],	
  	xlab="M2",ylab="M3",	
  	pch=20)
  dev.off()
}
## they are monotonously increasing relationships, so doesn't matter which samples to use.
```



## Trim samples and genes
### Load Clinical Data and Prepare for Analysis
```{r}

meta.clinical <- read.table(file.path(metabric_dir,"data_clinical_patient.txt"),sep="\t",header=T)
table(meta.clinical$ER_IHC) ## 1817 POSITIVE, 609 NEGATIVE

meta.clinical2 <- read.table(file.path(metabric_dir,"data_clinical_sample.txt"),sep="\t",header=T)
table(meta.clinical2$ER_STATUS) ## 1825 - not used this one

## join the two clinical info
meta.clinical <- meta.clinical %>% left_join(meta.clinical2,by="PATIENT_ID")

meta.clinical$PATIENT_ID <- gsub("-",".",meta.clinical$PATIENT_ID)

##
used.ids <- colnames(meta.m3)
table(used.ids %in% meta.clinical$PATIENT_ID) ## all samples' records exist in clinical metadata

meta.clinical <- meta.clinical %>% filter(PATIENT_ID %in% used.ids)
```

### Disease Status and Patient IDs per Subtype

```{r}
# Filter for known ER, PR, and HER2 status
meta.clinical <- meta.clinical %>%
  filter(ER_STATUS %in% c("Positive", "Negative")) %>%
  filter(PR_STATUS %in% c("Positive", "Negative")) %>%
  filter(HER2_STATUS %in% c("Positive", "Negative"))

# Extract patient IDs for each subtype
meta.ids <- list(
  hr = filter(meta.clinical, ER_STATUS == "Positive" | PR_STATUS == "Positive", HER2_STATUS == "Negative") %>% pull(PATIENT_ID),
  her2 = filter(meta.clinical, ER_STATUS == "Negative", PR_STATUS == "Negative", HER2_STATUS == "Positive") %>% pull(PATIENT_ID),
  dp = filter(meta.clinical, ER_STATUS == "Positive" | PR_STATUS == "Positive", HER2_STATUS == "Positive") %>% pull(PATIENT_ID),
  tnbc = filter(meta.clinical, ER_STATUS == "Negative", PR_STATUS == "Negative", HER2_STATUS == "Negative") %>% pull(PATIENT_ID)
)
```

### Visualize Patient Subtypes with Venn Diagram

```{r}
# Prepare data for Venn diagram visualization
mm <- with(meta.clinical, cbind(
  `ER+` = ER_STATUS == "Positive",
  `PR+` = PR_STATUS == "Positive",
  `HER2+` = HER2_STATUS == "Positive"
))

# Convert logical values to numeric for compatibility
mm <- as.data.frame(mm)
mm[] <- lapply(mm, as.integer)
rownames(mm) <- meta.clinical$PATIENT_ID

# Generate Venn diagram and save as PDF
pdf(file.path(fig_dir, "3_prep_metabric", "metabric_brca_subtypes.pdf"), width = 7, height = 7)
vennDiagram(as.matrix(mm), circle.col = c("blue", "red", "green"), main = "METABRIC samples")
dev.off()
```

### Remove Redundant Genes and Retain Most Abundantly Expressed Variants

```{r}
remove_redundant_genes <- function(expr_matrix, used_ids) {
  # Calculate row means for the expression matrix, removing NA values
  row_means <- rowMeans(expr_matrix, na.rm = TRUE)
  
  # Generate a vector of unique gene symbols
  gene_symbols <- rownames(expr_matrix)
  
  # Apply a function over each gene symbol to find the index of the entry with the maximum mean expression
  idx <- tapply(seq_along(row_means), gene_symbols, function(i) {
    this_means <- row_means[i]
    max_mean_idx <- which(this_means == max(this_means))
    return(i[max_mean_idx])
  }, simplify = TRUE)
  
  # Flatten the list to get a simple vector of indices (in case of multiple max means, take the first)
  idx <- unlist(idx, use.names = FALSE)
  
  # Subset the expression matrix to include only selected indices
  cleaned_matrix <- expr_matrix[idx, , drop = FALSE]
  
  # Ensure the matrix only includes samples present in the clinical data
  cleaned_matrix <- cleaned_matrix[, used_ids, drop = FALSE]
  
  # Correct row names by ensuring only unique gene symbols are retained
  cleaned_matrix_rownames <- names(row_means)[idx]
  rownames(cleaned_matrix) <- cleaned_matrix_rownames[!duplicated(cleaned_matrix_rownames)]
  
  return(cleaned_matrix)
}

# Apply the function to METABRIC expression matrices
meta.m1.cleaned <- remove_redundant_genes(meta.m1, used.ids)
meta.m3.cleaned <- remove_redundant_genes(meta.m3, used.ids)
```
### Process Expression Data for Analysis
```{r}
# Filter matrices to include only unique genes and samples present in clinical data
meta.syms <- intersect(rownames(meta.m1.cleaned), rownames(meta.m3.cleaned))
meta_m1 <- meta.m1.cleaned[meta.syms, used.ids]
meta_m3 <- meta.m3.cleaned[meta.syms, used.ids]
```

## Remove artifacts
### Define threshold for expression: `exp.th`
```{r}
mm1 <- meta.m1
mm3 <- meta.m3

# Calculate the mean expression for each gene across samples, excluding NA values
med.m1 <- apply(mm1, 1, mean, na.rm = TRUE)

# Generate a histogram to visually inspect the distribution of mean expression values
x <- hist(mm1, breaks = 1000)
mean.x <- x$mids[which(x$counts == max(x$counts))]

# Draw a vertical line at the most common expression value (mode)
abline(v = mean.x, col = 2)

# Identify negative deviations from the mode and calculate their standard deviation
negs <- mm1[mm1 < mean.x] - mean.x
negs <- negs[!is.na(negs)]
sd.x <- sqrt(sum(negs^2) / length(negs))

# Overlay a normal distribution that matches the mode and spread of the data
xs <- x$mids
ds <- dnorm(xs, mean = mean.x, sd = sd.x)
f <- max(x$counts) / max(ds)
lines(xs, ds * f, col = 3)

# Determine a threshold for expression based on a high percentile (e.g., the 99.9th percentile)
p.thres <- 1 - 10^-3
exp.th <- qnorm(p.thres, mean = mean.x, sd = sd.x)
abline(v = exp.th, col = 2)

if(0){
  pdf(file.path(fig_dir,"3_prep_metabric","prep_hlaa_exp1.pdf"),width=7,height=7)
  par(mfrow=c(3,1))
  rng <- range(mm1[,],na.rm=T)
  x <- hist(mm1[,],breaks=1000,xlim=rng,border=NA,col="grey60",freq=TRUE,
       main="METABRIC: Expression of all genes",
       xlab="Expression (log2)")
  abline(v=mean.x)
  lines(xs,ds,col="steelblue",lwd=2) ## doesn't fit
  abline(v=exp.th,col=2)
  hist(mm1["HLA-A",],breaks=x$breaks,xlim=rng,border=NA,col="grey60",
       main="METABRIC: Expression of HLA-A",
       xlab="Expression (log2)")
  abline(v=exp.th,col=2)
  hist(mm1["HLA-C",],breaks=x$breaks,xlim=rng,border=NA,col="grey60",
      main="METABRIC: Expression of HLA-C",
      xlab="Expression (log2)")
  abline(v=exp.th,col=2)
  dev.off()
}

```

### Impute 10 NAs in `mm1` with bg value (`mean.x`)
```{r}
# Identify positions of NA values in the expression matrix
na_positions <- which(is.na(mm1), arr.ind = TRUE)

# Replace NAs with the background expression value (mean.x)
mm1[is.na(mm1)] <- mean.x
```

### assess expression below threshold
```{r}
# Count the number of expressions below the defined threshold for each gene
has.0 <- apply(mm1, 1, function(xx) sum(xx < exp.th))

# Calculate the median expression for each gene
med.0 <- apply(mm1, 1, median)

```

### Identify genes lacking expression artificially - can skip this... check if `significant.genes` contain the module genes
```{r}
# Reassign NA values to mean.x for consistency
mm1[is.na(mm1)] <- mean.x

# Analyze expression patterns for each gene to identify artificial lack of expression
lst <- parallel::mclapply(uniq.syms1, function(sym) {
  this <- mm1[sym,]
  
  # Model selection using Bayesian Information Criterion (BIC) for Gaussian mixture models
  bic <- mclustBIC(this, G = 1:2, modelNames = "V", verbose = FALSE)
  g <- which.max(bic)
  mc <- Mclust(this, G = g, modelNames = "V", verbose = FALSE)
  mns <- mc$parameters$mean
  
  # Determine if expression patterns indicate artificial suppression
  if(g == 1) {
    peaks <- c(mns, NA)
    is.between <- NA
  } else if(g == 2) {
    peaks <- sort(mns)
    max.min <- max(this[mc$classification == 1])
    is.between <- max.min > min(mns) && max.min < max(mns)
  }
  
  is.bg <- min(mns) < exp.th
  max.sig <- max(mns) > exp.th
  
  return(c(sym = sym,
           g = g,
           is.bg = as.logical(is.bg),
           sig = as.logical(max.sig),
           p1 = peaks[1],
           p2 = peaks[2],
           is.between = as.logical(is.between)))
}, mc.cores = 4)

# Convert list to data frame for easier handling
lst1 <- as.data.frame(do.call(rbind, lst), stringsAsFactors = FALSE) %>%
  mutate(is.bg = as.logical(is.bg),
         sig = as.logical(sig),
         is.between = as.logical(is.between),
         p1 = as.numeric(p1),
         p2 = as.numeric(p2))

```

```{r}
mm1[is.na(mm1)] <- mean.x
uniq.syms1 <- rownames(mm1)
lst <- parallel::mclapply(uniq.syms1,function(sym){
  this <- mm1[sym,]
  
  ## model selection
  set.seed(1)
  bic <- mclustBIC(this,G=1:2,modelNames="V",verbose=FALSE)
  g <- which.max(bic)
  mc <- Mclust(this,G=g,modelNames="V",verbose=FALSE)
  mns <- mc$parameters$mean
    
  if(g==1){
    peaks <- c(mns,NA)
    is.between <- NA
  }else if(g==2){
    peaks <- sort(mns)
    i <- which.min(mns)
    max.min <- max(this[mc$classification==1])
    is.between <- max.min > min(mns) && max.min < max(mns)
  }
  
  is.bg <- min(mns) < exp.th
  max.sig <- max(mns) > exp.th
  
  return(c(sym=sym,
           g=g,
           is.bg=is.bg,
           sig=max.sig,
           p1=peaks[1],
           p2=peaks[2],
           is.between=is.between
           ))
},mc.cores=4)
```


```{r}
saveRDS(lst,file.path(obj_dir,"1-4_prep","lst.rds")))
```


```{r}
# Convert the list to a data frame for further analysis and visualization
lst1 <- as.data.frame(do.call(rbind, lst), stringsAsFactors = FALSE) %>%
  rename(p1 = "p1.1", p2 = "p2.2") %>%
  mutate(is_bg = as.logical(is_bg),
         sig = as.logical(sig),
         is_between = as.logical(is_between),
         p1 = as.numeric(p1),
         p2 = as.numeric(p2))

# Merge the results with additional gene metrics for comprehensive analysis
df <- cbind(lst1,
            median = med.0,
            n_samples_below_threshold = has.0) %>%
  mutate(difference = p2 - p1)
df$is_between[is.na(df$is_between)] <- FALSE

# The 'df' data frame now contains detailed results from the artifact analysis,
# including whether each gene's expression is artificially low ('is_bg'),
# the presence of significant expression ('sig'), and the configuration of expression peaks ('is_between').
```

#### Visual Checking (Optional)
```{r}
# Assign patient subtype based on metadata
n.samples <- ncol(mm1)
patients <- colnames(mm1)
subtype <- rep(NA, length(patients))
names(subtype) <- patients

# Map patient IDs to subtypes
subtype[patients %in% meta.ids$hr] <- "HR+"
subtype[patients %in% meta.ids$her2] <- "HER2+"
subtype[patients %in% meta.ids$dp] <- "Double Positive"
subtype[patients %in% meta.ids$tnbc] <- "TNBC"
subtype <- factor(subtype, levels = c("HR+", "Double Positive", "HER2+", "TNBC"))

# Perform ANOVA for each gene across subtypes to check for significant differences
p.values <- sapply(df$sym, function(sym) {
  gene_data <- data.frame(expression = mm1[sym, ], subtype = subtype)
  aov_result <- aov(expression ~ subtype, data = gene_data)
  p.value <- summary(aov_result)[[1]]["subtype", "Pr(>F)"]
  return(p.value)
})

# Add p-values to the dataframe
df <- mutate(df, p.value = p.values)

# Filter for significant genes with criteria defined earlier
significant.genes <- df %>%
  filter(!is.na(p2), is.between == TRUE, g == 2, is.bg == TRUE, sig, median > exp.th, p.value > 1e-20, n.samples.bg < n.samples * .25) %>%
  arrange(desc(difference))

# Boxplot examples for visual inspection
boxplot(mm1["ESR1",] ~ subtype, main = "ESR1 Expression by Subtype")
boxplot(mm1["SCAMP1",] ~ subtype, main= "SCAMP1 Expression by Subtype") # above thres
boxplot(mm1["HLA-A",] ~ subtype, main= "HLA-A Expression by Subtype") # above thres
boxplot(mm1["ERAP2",] ~ subtype, main= "HLA-A Expression by Subtype") # above thres
abline(h = exp.th, col = 2) # Threshold line

if(0){
  boxplot(mm1["AR",user.ids] ~ sta,las=2)

  ## thres for # bg samples
  xx <- hist(df$n.smpls.bg,breaks=100)
  abline(v=n.smpls * .25,col=2)

  hist(significant.genes$d,breaks=100)
  hist(mm["ESR1",])
  hist(mm["ANKRD30A",],breaks=1000)
  hist(mm["AGR3",],breaks=1000)
  hist(mm["GPT",],breaks=1000)
}
```

#### Make the low values `NA` - can be skipped as well.

```{r}
# Copy original matrices for modification
mm1.0 <- mm1
mm3.0 <- mm3

# Replace expressions below threshold with NA
mm1.0[mm1 < exp.th] <- NA
mm3.0[mm3 < exp.th] <- NA

# Update METABRIC data matrices to remove artificially low expressions
meta.m1 <- mm1.0
meta.m3 <- mm3.0

mm1.0 <- mm1
mm3.0 <- mm3
mm1.1 <- mm1[significant.genes$sym,]
mm3.1 <- mm3[significant.genes$sym,]

mm1.1[mm1[significant.genes$sym,] < exp.th] <- NA
mm3.1[mm1[significant.genes$sym,] < exp.th] <- NA
sum(is.na(mm1.1)) # 6437
sum(is.na(mm3.1)) # 6437

mm1.0[significant.genes$sym,] <- mm1.1
mm3.0[significant.genes$sym,] <- mm3.1

meta.m1 <- mm1.0
meta.m3 <- mm3.0

range(rowSums(is.na(mm3.0))) # 0-465
range(colSums(is.na(mm3.0))) # 0-13

  ## we should use mm3 (zscore)
mm3.2 <- impute::impute.knn(mm3.0,k=10)[[1]]

meta.m3i <- mm3.2
if(0){
  was.na <- is.na(mm3.1["HLA-A",])
  plot(mm3.2["CD8A",],mm3.2["HLA-A",],col=was.na+1)
  cor(mm3.2["CD8A",],mm3.2["HLA-A",],method="spearman")
  cor(mm3.2["CD8A",!was.na],mm3.2["HLA-A",!was.na],method="spearman")
  cor(mm3.2["CD8A",was.na],mm3.2["HLA-A",was.na],method="spearman")
  
  plot(mm3.2["ESR1",],mm3.2["HLA-A",],col=was.na+1)
  cor(mm3.2["ESR1",],mm3.2["HLA-A",],method="spearman")
  cor(mm3.2["ESR1",!was.na],mm3.2["HLA-A",!was.na],method="spearman")
  cor(mm3.2["ESR1",was.na],mm3.2["HLA-A",was.na],method="spearman")
}
  
if(0){
  mm1.2 <- impute.knn(mm1.0,k=10)
  was.na <- is.na(mm1.1["HLA-A",])
  plot(mm1.2["CD8A",],mm1.2["HLA-A",],col=was.na+1)
  cor(mm1.2["CD8A",],mm1.2["HLA-A",],method="spearman")
  cor(mm1.2["CD8A",!was.na],mm1.2["HLA-A",!was.na],method="spearman")
  cor(mm1.2["CD8A",was.na],mm1.2["HLA-A",was.na],method="spearman")
  
  cor(mm1.2["ESR1",],mm1.2["HLA-A",],method="spearman")
  cor(mm1.2["ESR1",!was.na],mm1.2["HLA-A",!was.na],method="spearman")
  cor(mm1.2["ESR1",was.na],mm1.2["HLA-A",was.na],method="spearman")
}

```



## Save data in rda
```{r}
meta.syms <- uniq.syms1
meta.exp.th <- exp.th
meta.df <- df
meta.significant.genes <- significant.genes # 20 genes

save(meta.ids,meta.clinical,meta.syms,meta.m1,meta.m3,meta.m3i,
     meta.exp.th,meta.df,meta.significant.genes,
     file=file.path(obj_dir,"1-4_prep","metabric_processed_v3.rda"))
```
```{r}
load(file.path(obj_dir,"1-4_prep","metabric_processed_v3.rda"))
```

